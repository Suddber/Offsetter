# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Offsetter
                                 A QGIS plugin
 This plugin adds offset a field for offset values to line layers to automatically display lines of different categories that are lying on top of each other.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-05-24
        copyright            : (C) 2025 by Suddber
        email                : suddb@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Suddber'
__date__ = '2025-05-24'
__copyright__ = '(C) 2025 by Suddber'

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsPointXY,
                       QgsGeometry,
                       QgsProcessingParameterField,
                       QgsField,
                       QgsFeatureRequest)


class OffsetterAlgorithm(QgsProcessingAlgorithm):
    
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    CATEGORY_FIELD = 'CATEGORY_FIELD'

    def initAlgorithm(self, config):
        
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer'),
                [QgsProcessing.TypeVectorLine ]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.CATEGORY_FIELD,
                description="Field for line categories to display",
                parentLayerParameterName=self.INPUT,
                type=QgsProcessingParameterField.Any,
                optional=False
            )
        )

    def point_to_5_decimal_places(self, point):
        # point should be QgsPointXY
        X = point[0]
        Y = point[1]
        X_new = (int(X*100000))/100000
        Y_new = (int(Y*100000))/100000
        new_point = QgsPointXY(X_new,Y_new)
        return new_point

    

    def processAlgorithm(self, parameters, context, feedback):

        # Retrieve the feature source and sink
        source = self.parameterAsSource(parameters, self.INPUT, context)
        category = self.parameterAsString(parameters, self.CATEGORY_FIELD, context)

        new_fields = source.fields()
        new_fields.append(QgsField('section_id', QVariant.Int))
        new_fields.append(QgsField('direction', QVariant.Int))
        new_fields.append(QgsField('position', QVariant.Int))
        new_fields.append(QgsField('same_count', QVariant.Int))
        new_fields.append(QgsField('offset', QVariant.Int))
        
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, new_fields, source.wkbType(), source.sourceCrs())

        feedback.setProgressText('Input loaded')

        # Compute the number of steps to display within the progress bar and
        # get features from source
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()

        # determine direction, count same geometries, sort
        wkt_count = {}
        wkt_direction = {}
        wkt_positionlist = {}
        section_id = {}
        id_counter = 1
        
        for current, f in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break

            # first, new geometries are created, consisting of forst and last vertex
            # reason ist tha some lines have (almost) same geometry, but slightly different vertices
            # second, WKT's of new geometries are compared
            geom = f.geometry()
            nodes = geom.asPolyline()
            
            n = len(nodes)
            startnode = nodes[0]
            endnode = nodes[n-1]
            cut_startnode = self.point_to_5_decimal_places(startnode)
            cut_endnode = self.point_to_5_decimal_places(endnode)
            start_end_nodes = [cut_startnode, cut_endnode]
            start_end_geom = QgsGeometry.fromPolylineXY(start_end_nodes)
            wkt = start_end_geom.asWkt()
            
            start_end_nodes.reverse() 
            reverse_start_end_geom = QgsGeometry.fromPolylineXY(start_end_nodes)
            reversewkt = reverse_start_end_geom.asWkt()
            
            cat = f[category]
            
            if wkt in wkt_direction:
                if wkt_direction[wkt] == 1:
                    # this is the main direction
                    if cat in wkt_positionlist[wkt]:
                        pass
                    else:
                        wkt_count[wkt] += 1
                        wkt_positionlist[wkt].append(cat)
                        wkt_positionlist[wkt].sort()
                elif wkt_direction[wkt] == 2:
                    # this is the opposite direction
                    if cat in wkt_positionlist[reversewkt]:
                        pass
                    else:
                        wkt_count[reversewkt] += 1
                        wkt_positionlist[reversewkt].append(cat)
                        wkt_positionlist[reversewkt].sort()
                else:
                    feedback.reportError('Fehler 1!')
            elif reversewkt in wkt_direction:
                # this is the new opposite direction
                wkt_direction[wkt] = 2
                if cat in wkt_positionlist[reversewkt]:
                    pass
                else:
                    wkt_count[reversewkt] += 1
                    wkt_positionlist[reversewkt].append(cat)
                    wkt_positionlist[reversewkt].sort() 
            else:
                # this is the new main direction
                wkt_direction[wkt] = 1
                wkt_count[wkt] = 1
                wkt_positionlist[wkt] = [cat]
                section_id[wkt] = id_counter
                id_counter += 1
            
            # Update the first half of progress bar
            feedback.setProgress(int((current * total)/2))

        feedback.setProgressText('Direction, same count and sorting retrieved')
        
        # make editable layer from source layer

        layer = source.materialize(QgsFeatureRequest())

        layer_provider=layer.dataProvider()
        layer_provider.addAttributes([QgsField('section_id', QVariant.Int),
                                      QgsField('direction', QVariant.Int),
                                       QgsField('position', QVariant.Int),
                                       QgsField('same_count', QVariant.Int),
                                       QgsField('offset', QVariant.Int)])
        layer.updateFields()

        new_features = layer.getFeatures()

        # put erverything into the output layer
        
        for current, f in enumerate(new_features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break
            
            geom = f.geometry()
            nodes = geom.asPolyline()
            n = len(nodes)
            startnode = nodes[0]
            endnode = nodes[n-1]
            cut_startnode = self.point_to_5_decimal_places(startnode)
            cut_endnode = self.point_to_5_decimal_places(endnode)
            start_end_nodes = [cut_startnode, cut_endnode]
            start_end_geom = QgsGeometry.fromPolylineXY(start_end_nodes)
            wkt = start_end_geom.asWkt()
            start_end_nodes.reverse() 
            reverse_start_end_geom = QgsGeometry.fromPolylineXY(start_end_nodes)
            reversewkt = reverse_start_end_geom.asWkt()
            cat = f[category]

            f_direction = wkt_direction[wkt]
            
            f['direction'] = f_direction
            if wkt in wkt_count:
                f_count = wkt_count[wkt]
                f['same_count'] = f_count
                index = wkt_positionlist[wkt].index(cat)
                f['position'] = index
                f['section_id'] = section_id[wkt]
            elif reversewkt in wkt_count:
                f_count = wkt_count[reversewkt]
                f['same_count'] = f_count
                index = wkt_positionlist[reversewkt].index(cat)
                f['position'] = index
                f['section_id'] = section_id[reversewkt]
            else:
                feedback.reportError('Fehler 3!')
            # die Formel!
            offset = 2*index-f_count+1
            # falls RÃ¼ckrichtung
            if f_direction == 2:
                offset = offset*(-1)
            f['offset'] = offset
            layer.updateFeature(f)



            # Add a feature in the sink
            sink.addFeature(f, QgsFeatureSink.FastInsert)

            # Update the second half of progress bar 
            feedback.setProgress(int(((current * total)/2)+50))

        feedback.setProgressText('Output layer created')
  
        return {self.OUTPUT: dest_id}

    def name(self):
        
        return 'Offsetter'

    def displayName(self):
        
        return self.tr(self.name())

    def group(self):
        
        return self.tr(self.groupId())

    def groupId(self):
        
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return OffsetterAlgorithm()
